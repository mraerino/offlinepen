<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/utils/debounce.html">
<link rel="import" href="../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../bower_components/app-route/app-route.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">

<dom-module id="view-editor">
  <template>
    <style>
    </style>

    <app-route route="[[ route ]]" pattern="/:penId" data="{{ routeData }}" active="{{ editorActive }}"></app-route>

    <header>
      <a href="/list" title="Back to pen list">&lt;</a>
      <paper-input label="Name of the pen" value="{{ penMeta.name }}"></paper-input>
      <p>[[ saveState ]]</p>
    </header>
  </template>
</dom-module>

<script>
  class ViewEditor extends Polymer.Element {
    static get is() { return 'view-editor'; }

    static get properties() {
      return {
        route: {
          type: Object
        },
        currentId: {
          type: String,
          value: () => "",
          observer: 'fetchPen'
        },
        penMeta: {
          type: Object
        },
        hasSaved: {
          type: Boolean,
          value: true
        },
        saveState: {
          type: String,
          computed: 'computeSaveState(hasSaved)'
        },
        fetching: {
          type: Boolean,
          value: false
        }
      };
    }

    static get observers() {
      return [
        'routeChanged(routeData.*, editorActive)',
        'metaChanged(penMeta.*)'
      ];
    }

    routeChanged(change, active) {
      if(!active) {
        this.currentId = "";
        this.dispatchEvent(new CustomEvent('op-navigateTo', {
          detail: { path: '/list' },
          bubbles: true,
          composed: true
        }));
        return;
      }

      if(change.base && change.base.penId) {
        this.currentId = change.base.penId;
      }
    }

    fetchPen(id) {
      this.fetching = true;
      OfflinePen.db.pens.get(id)
        .then(pen => this.penMeta = pen)
        .then(() => Polymer.Async.timeOut.run(() => this.fetching = false));
    }

    metaChanged(change) {
      if(this.currentId === "" || this.fetching || change.path === 'penMeta.id') {
        return;
      }

      this.hasSaved = false;
      this._metaDebouncer = Polymer.Debouncer.debounce(
        this._metaDebouncer,
        Polymer.Async.timeOut.after(1000),
        () => OfflinePen.db.pens
          .update(this.currentId, Object.assign({}, change.base, { updatedAt: (new Date()).getTime() }))
          .then(() => this.hasSaved = true)
      );
    }

    computeSaveState(saved) {
      return saved ? 'Saved.' : 'Changed...';
    }
  }

  customElements.define(ViewEditor.is, ViewEditor);
</script>
